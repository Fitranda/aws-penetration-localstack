#!/usr/bin/env python3
"""
AWS Penetration Testing Toolkit untuk LocalStack
Automated tools untuk testing common AWS vulnerabilities
"""

import boto3
import json
import requests
import subprocess
import sys
from botocore.exceptions import ClientError
from datetime import datetime
import os

class AWSPentestToolkit:
    def __init__(self, endpoint_url='http://localhost:4566'):
        self.endpoint_url = endpoint_url
        self.session = boto3.Session(
            aws_access_key_id='test',
            aws_secret_access_key='test',
            region_name='us-east-1'
        )
        
    def get_client(self, service):
        """Get AWS client for specific service"""
        return self.session.client(service, endpoint_url=self.endpoint_url)
    
    def banner(self):
        """Display banner"""
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               AWS Penetration Testing Toolkit            ‚ïë
‚ïë                    LocalStack Edition                    ‚ïë
‚ïë                                                          ‚ïë
‚ïë  ‚ö†Ô∏è  FOR EDUCATIONAL PURPOSES ONLY ‚ö†Ô∏è                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
    
    def check_localstack(self):
        """Check if LocalStack is running"""
        try:
            response = requests.get(f"{self.endpoint_url}/health")
            if response.status_code == 200:
                print("‚úÖ LocalStack is running")
                return True
            else:
                print("‚ùå LocalStack is not responding")
                return False
        except Exception as e:
            print(f"‚ùå Cannot connect to LocalStack: {e}")
            return False
    
    def s3_reconnaissance(self):
        """S3 Bucket reconnaissance and enumeration"""
        print("\nüîç === S3 Reconnaissance ===")
        s3 = self.get_client('s3')
        
        try:
            # List all buckets
            response = s3.list_buckets()
            buckets = response.get('Buckets', [])
            
            if not buckets:
                print("No S3 buckets found")
                return
            
            print(f"Found {len(buckets)} bucket(s):")
            
            for bucket in buckets:
                bucket_name = bucket['Name']
                print(f"\nüì¶ Bucket: {bucket_name}")
                
                # Check bucket policy
                try:
                    policy = s3.get_bucket_policy(Bucket=bucket_name)
                    print("  üîì Has bucket policy (potentially public)")
                    
                    # Try to parse policy
                    policy_doc = json.loads(policy['Policy'])
                    for statement in policy_doc.get('Statement', []):
                        if statement.get('Principal') == '*':
                            print(f"  ‚ö†Ô∏è  PUBLIC ACCESS: {statement.get('Action', 'Unknown action')}")
                            
                except ClientError as e:
                    if e.response['Error']['Code'] == 'NoSuchBucketPolicy':
                        print("  üîí No bucket policy")
                    else:
                        print(f"  ‚ùå Error checking policy: {e}")
                
                # Try to list objects
                try:
                    objects = s3.list_objects_v2(Bucket=bucket_name)
                    if 'Contents' in objects:
                        print(f"  üìÑ Contains {len(objects['Contents'])} object(s)")
                        for obj in objects['Contents'][:5]:  # Show first 5
                            print(f"     - {obj['Key']} ({obj['Size']} bytes)")
                        if len(objects['Contents']) > 5:
                            print(f"     ... and {len(objects['Contents']) - 5} more")
                    else:
                        print("  üì≠ Empty bucket")
                        
                except ClientError as e:
                    print(f"  ‚ùå Cannot list objects: {e.response['Error']['Code']}")
                
        except Exception as e:
            print(f"‚ùå S3 reconnaissance failed: {e}")
    
    def iam_enumeration(self):
        """IAM enumeration and privilege escalation detection"""
        print("\nüîç === IAM Enumeration ===")
        iam = self.get_client('iam')
        
        try:
            # List users
            users = iam.list_users()
            print(f"Found {len(users['Users'])} user(s):")
            
            for user in users['Users']:
                username = user['UserName']
                print(f"\nüë§ User: {username}")
                
                # Check attached policies
                try:
                    attached_policies = iam.list_attached_user_policies(UserName=username)
                    for policy in attached_policies['AttachedPolicies']:
                        print(f"  üìã Policy: {policy['PolicyName']}")
                        
                        # Get policy details
                        try:
                            policy_details = iam.get_policy(PolicyArn=policy['PolicyArn'])
                            policy_version = iam.get_policy_version(
                                PolicyArn=policy['PolicyArn'],
                                VersionId=policy_details['Policy']['DefaultVersionId']
                            )
                            
                            # Check for dangerous permissions
                            policy_doc = policy_version['PolicyVersion']['Document']
                            self.check_dangerous_permissions(policy_doc, f"    ")
                            
                        except Exception as e:
                            print(f"    ‚ùå Error getting policy details: {e}")
                            
                except Exception as e:
                    print(f"  ‚ùå Error listing policies: {e}")
            
            # List roles
            roles = iam.list_roles()
            print(f"\nFound {len(roles['Roles'])} role(s):")
            
            for role in roles['Roles'][:10]:  # Limit to first 10
                print(f"  üé≠ Role: {role['RoleName']}")
                
                # Check assume role policy
                assume_role_policy = role['AssumeRolePolicyDocument']
                if isinstance(assume_role_policy, str):
                    assume_role_policy = json.loads(assume_role_policy)
                
                for statement in assume_role_policy.get('Statement', []):
                    principal = statement.get('Principal', {})
                    if principal == '*' or (isinstance(principal, dict) and principal.get('AWS') == '*'):
                        print(f"    ‚ö†Ô∏è  Can be assumed by anyone!")
                        
        except Exception as e:
            print(f"‚ùå IAM enumeration failed: {e}")
    
    def check_dangerous_permissions(self, policy_doc, indent=""):
        """Check for dangerous IAM permissions"""
        dangerous_actions = [
            'iam:CreateRole',
            'iam:AttachRolePolicy',
            'iam:PutRolePolicy',
            'iam:CreateUser',
            'iam:AttachUserPolicy',
            'iam:PutUserPolicy',
            'sts:AssumeRole',
            '*'
        ]
        
        for statement in policy_doc.get('Statement', []):
            if statement.get('Effect') == 'Allow':
                actions = statement.get('Action', [])
                if isinstance(actions, str):
                    actions = [actions]
                
                for action in actions:
                    if action in dangerous_actions:
                        print(f"{indent}‚ö†Ô∏è  DANGEROUS: {action}")
    
    def lambda_code_analysis(self):
        """Analyze Lambda functions for vulnerabilities"""
        print("\nüîç === Lambda Code Analysis ===")
        lambda_client = self.get_client('lambda')
        
        try:
            functions = lambda_client.list_functions()
            
            if not functions['Functions']:
                print("No Lambda functions found")
                return
            
            print(f"Found {len(functions['Functions'])} function(s):")
            
            for func in functions['Functions']:
                func_name = func['FunctionName']
                print(f"\n‚ö° Function: {func_name}")
                print(f"   Runtime: {func['Runtime']}")
                print(f"   Role: {func['Role']}")
                
                # Check environment variables
                if 'Environment' in func and 'Variables' in func['Environment']:
                    env_vars = func['Environment']['Variables']
                    print(f"   üîß Environment Variables: {len(env_vars)}")
                    
                    # Check for sensitive data in env vars
                    sensitive_patterns = ['password', 'secret', 'key', 'token', 'api']
                    for var_name, var_value in env_vars.items():
                        for pattern in sensitive_patterns:
                            if pattern.lower() in var_name.lower():
                                print(f"     ‚ö†Ô∏è  Potentially sensitive: {var_name}")
                
                # Try to get function code (won't work in LocalStack but good to show)
                try:
                    code_info = lambda_client.get_function(FunctionName=func_name)
                    print(f"   üìÑ Code Location: {code_info['Code'].get('Location', 'N/A')}")
                except Exception as e:
                    print(f"   ‚ùå Cannot retrieve code: {e}")
                    
        except Exception as e:
            print(f"‚ùå Lambda analysis failed: {e}")
    
    def dynamodb_enumeration(self):
        """DynamoDB enumeration and potential injection points"""
        print("\nüîç === DynamoDB Enumeration ===")
        dynamodb = self.get_client('dynamodb')
        
        try:
            tables = dynamodb.list_tables()
            
            if not tables['TableNames']:
                print("No DynamoDB tables found")
                return
            
            print(f"Found {len(tables['TableNames'])} table(s):")
            
            for table_name in tables['TableNames']:
                print(f"\nüóÉÔ∏è  Table: {table_name}")
                
                # Get table description
                try:
                    table_desc = dynamodb.describe_table(TableName=table_name)
                    table_info = table_desc['Table']
                    
                    print(f"   Status: {table_info['TableStatus']}")
                    print(f"   Item Count: {table_info.get('ItemCount', 'Unknown')}")
                    
                    # Check key schema
                    key_schema = table_info.get('KeySchema', [])
                    for key in key_schema:
                        print(f"   üîë Key: {key['AttributeName']} ({key['KeyType']})")
                    
                    # Try to scan table (limited items)
                    try:
                        scan_result = dynamodb.scan(TableName=table_name, Limit=5)
                        items = scan_result.get('Items', [])
                        if items:
                            print(f"   üìÑ Sample items: {len(items)}")
                            for i, item in enumerate(items[:2]):  # Show first 2 items
                                print(f"     Item {i+1}: {list(item.keys())}")
                    except Exception as e:
                        print(f"   ‚ùå Cannot scan table: {e}")
                        
                except Exception as e:
                    print(f"   ‚ùå Cannot describe table: {e}")
                    
        except Exception as e:
            print(f"‚ùå DynamoDB enumeration failed: {e}")
    
    def setup_vulnerable_environment(self):
        """Setup vulnerable AWS environment for testing"""
        print("\nüöß === Setting up Vulnerable Environment ===")
        
        # Setup vulnerable S3 bucket
        print("Setting up vulnerable S3 bucket...")
        self.setup_vulnerable_s3()
        
        # Setup vulnerable IAM
        print("Setting up vulnerable IAM...")
        self.setup_vulnerable_iam()
        
        # Setup vulnerable Lambda
        print("Setting up vulnerable Lambda...")
        self.setup_vulnerable_lambda()
        
        # Setup vulnerable DynamoDB
        print("Setting up vulnerable DynamoDB...")
        self.setup_vulnerable_dynamodb()
        
        print("\n‚úÖ Vulnerable environment setup complete!")
        print("‚ö†Ô∏è  This environment contains intentional vulnerabilities for testing purposes only!")
    
    def setup_vulnerable_s3(self):
        """Setup vulnerable S3 bucket"""
        s3 = self.get_client('s3')
        bucket_name = 'vulnerable-pentest-bucket'
        
        try:
            # Create bucket
            s3.create_bucket(Bucket=bucket_name)
            
            # Upload sensitive files
            sensitive_files = {
                'config/database.conf': 'host=db.internal.com\nusername=admin\npassword=supersecret123',
                'secrets/api-keys.txt': 'api_key=sk-1234567890abcdef\nsecret_key=abc123def456',
                'logs/access.log': 'admin login from 192.168.1.100\nroot login from 10.0.0.5',
                'backup/users.sql': 'INSERT INTO users VALUES (1, "admin", "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8");'
            }
            
            for key, content in sensitive_files.items():
                s3.put_object(Bucket=bucket_name, Key=key, Body=content)
            
            # Set public read policy
            public_policy = {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Sid": "PublicReadGetObject",
                        "Effect": "Allow",
                        "Principal": "*",
                        "Action": "s3:GetObject",
                        "Resource": f"arn:aws:s3:::{bucket_name}/*"
                    }
                ]
            }
            
            s3.put_bucket_policy(Bucket=bucket_name, Policy=json.dumps(public_policy))
            print(f"‚úÖ Created vulnerable S3 bucket: {bucket_name}")
            
        except Exception as e:
            print(f"‚ùå Error setting up S3: {e}")
    
    def setup_vulnerable_iam(self):
        """Setup vulnerable IAM configuration"""
        iam = self.get_client('iam')
        
        try:
            # Create overprivileged user
            try:
                iam.create_user(UserName='pentester')
            except ClientError as e:
                if e.response['Error']['Code'] != 'EntityAlreadyExists':
                    raise
            
            # Create dangerous policy
            dangerous_policy = {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": [
                            "iam:CreateRole",
                            "iam:AttachRolePolicy",
                            "sts:AssumeRole",
                            "iam:PassRole"
                        ],
                        "Resource": "*"
                    }
                ]
            }
            
            try:
                iam.create_policy(
                    PolicyName='DangerousPrivEscPolicy',
                    PolicyDocument=json.dumps(dangerous_policy)
                )
            except ClientError as e:
                if e.response['Error']['Code'] != 'EntityAlreadyExists':
                    raise
            
            print("‚úÖ Created vulnerable IAM configuration")
            
        except Exception as e:
            print(f"‚ùå Error setting up IAM: {e}")
    
    def setup_vulnerable_lambda(self):
        """Setup vulnerable Lambda function"""
        lambda_client = self.get_client('lambda')
        
        vulnerable_code = '''
import json
import subprocess
import os

def lambda_handler(event, context):
    # VULNERABLE: Command injection
    command = event.get('command', 'whoami')
    
    try:
        # DANGEROUS: Direct shell execution
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        
        # VULNERABLE: Information disclosure
        env_vars = dict(os.environ)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'command_output': result.stdout,
                'error_output': result.stderr,
                'environment': env_vars  # Leaking environment variables
            })
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }
'''
        
        try:
            import zipfile
            import io
            
            # Create ZIP file
            zip_buffer = io.BytesIO()
            with zipfile.ZipFile(zip_buffer, 'w') as zip_file:
                zip_file.writestr('lambda_function.py', vulnerable_code)
            zip_buffer.seek(0)
            
            # Create function
            lambda_client.create_function(
                FunctionName='vulnerable-cmd-exec',
                Runtime='python3.9',
                Role='arn:aws:iam::123456789012:role/lambda-role',
                Handler='lambda_function.lambda_handler',
                Code={'ZipFile': zip_buffer.read()},
                Environment={
                    'Variables': {
                        'DB_PASSWORD': 'supersecret123',
                        'API_KEY': 'sk-vulnerable-key-123',
                        'SECRET_TOKEN': 'jwt-secret-token'
                    }
                }
            )
            
            print("‚úÖ Created vulnerable Lambda function: vulnerable-cmd-exec")
            
        except ClientError as e:
            if e.response['Error']['Code'] != 'ResourceConflictException':
                print(f"‚ùå Error setting up Lambda: {e}")
        except Exception as e:
            print(f"‚ùå Error setting up Lambda: {e}")
    
    def setup_vulnerable_dynamodb(self):
        """Setup vulnerable DynamoDB table"""
        dynamodb = self.get_client('dynamodb')
        
        try:
            # Create table
            try:
                dynamodb.create_table(
                    TableName='vulnerable-users',
                    KeySchema=[
                        {'AttributeName': 'user_id', 'KeyType': 'HASH'}
                    ],
                    AttributeDefinitions=[
                        {'AttributeName': 'user_id', 'AttributeType': 'S'}
                    ],
                    ProvisionedThroughput={
                        'ReadCapacityUnits': 5,
                        'WriteCapacityUnits': 5
                    }
                )
            except ClientError as e:
                if e.response['Error']['Code'] != 'ResourceInUseException':
                    raise
            
            # Insert vulnerable data
            vulnerable_users = [
                {
                    'user_id': {'S': 'admin'},
                    'password': {'S': 'admin123'},
                    'role': {'S': 'administrator'},
                    'api_key': {'S': 'sk-admin-key-vulnerable'}
                },
                {
                    'user_id': {'S': 'guest'},
                    'password': {'S': 'guest'},
                    'role': {'S': 'user'},
                    'sensitive_data': {'S': 'credit_card:4532-1234-5678-9012'}
                }
            ]
            
            for user in vulnerable_users:
                try:
                    dynamodb.put_item(TableName='vulnerable-users', Item=user)
                except Exception:
                    pass  # Ignore if already exists
            
            print("‚úÖ Created vulnerable DynamoDB table: vulnerable-users")
            
        except Exception as e:
            print(f"‚ùå Error setting up DynamoDB: {e}")
    
    def run_full_assessment(self):
        """Run complete penetration test assessment"""
        self.banner()
        
        if not self.check_localstack():
            print("Please start LocalStack first: docker-compose up -d")
            return
        
        print(f"\nüéØ Starting AWS Penetration Test Assessment")
        print(f"üìÖ Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 60)
        
        # Run all assessment modules
        self.s3_reconnaissance()
        self.iam_enumeration()
        self.lambda_code_analysis()
        self.dynamodb_enumeration()
        
        print("\n" + "=" * 60)
        print("‚úÖ Assessment Complete!")
        print("\nüìã Summary:")
        print("- Check S3 buckets for public access and sensitive data")
        print("- Review IAM permissions for privilege escalation paths")
        print("- Analyze Lambda functions for code vulnerabilities")
        print("- Examine DynamoDB tables for data exposure")
        print("\n‚ö†Ô∏è  Remember: This is for educational purposes only!")

def main():
    toolkit = AWSPentestToolkit()
    
    if len(sys.argv) < 2:
        print("Usage: python aws_pentest_toolkit.py [command]")
        print("\nCommands:")
        print("  setup     - Setup vulnerable environment")
        print("  assess    - Run full penetration test assessment")
        print("  s3        - S3 reconnaissance only")
        print("  iam       - IAM enumeration only")
        print("  lambda    - Lambda analysis only")
        print("  dynamodb  - DynamoDB enumeration only")
        return
    
    command = sys.argv[1].lower()
    
    if command == 'setup':
        toolkit.setup_vulnerable_environment()
    elif command == 'assess':
        toolkit.run_full_assessment()
    elif command == 's3':
        toolkit.banner()
        if toolkit.check_localstack():
            toolkit.s3_reconnaissance()
    elif command == 'iam':
        toolkit.banner()
        if toolkit.check_localstack():
            toolkit.iam_enumeration()
    elif command == 'lambda':
        toolkit.banner()
        if toolkit.check_localstack():
            toolkit.lambda_code_analysis()
    elif command == 'dynamodb':
        toolkit.banner()
        if toolkit.check_localstack():
            toolkit.dynamodb_enumeration()
    else:
        print(f"Unknown command: {command}")

if __name__ == "__main__":
    main()